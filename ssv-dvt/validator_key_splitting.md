# SSV DVT - Validator key splitting and operator roles

## Key shares & threshold

- (n, t) threshold model. The validator private key sk is split among n operator nodes using a DKG / secret-sharing scheme producing shares s1..sn. The public key pk (what’s registered on-chain) corresponds to sk. To sign a message (a block attest, beacon block signature, etc.) the protocol requires t partial signatures that are combined into a canonical full BLS signature.

    - Notation: (n,t) means n shares, threshold t.


- DKG (no trusted dealer). The key shares are generated by a distributed key-generation protocol so no single operator ever learns the whole sk. DKG also produces published commitments so everyone can verify shares are consistent.

    - Implementation note: SSV uses BLS signatures (BLS12-381) and a DKG/threshold BLS scheme; the exact DKG variant and verification details are implementation specifics — the high-level guarantees are the same.

- Security vs. liveness tradeoff.

    - Security (anti-collusion): Any group of t or more operators can produce signatures / reconstruct the key (depending on scheme). So to keep the private key secure you must assume < t operators may collude.

    - Liveness (failure tolerance): The system remains able to sign as long as at least t operators are online and participating. Thus it tolerates up to (n − t) offline or unavailable operators.

- Important formulas (use these to reason):

    - Max offline tolerated (liveness): F_offline = n − t

    - Collusion needed to break safety (compromise key / sign arbitrarily): C_collude = t

    - Tradeoff example:

        - (n=4, t=3) → tolerate 4−3=1 offline; 3 colluding breaks safety.

        - (n=3, t=2) → tolerate 1 offline; 2 colluding breaks safety (weaker anti-collusion).

- Double-use / equivocation risk: Because signing is threshold, the protocol must prevent an operator set from producing two conflicting but individually valid signatures for the same epoch/slot; that’s handled by the signing protocol + slashing rules on the chain.

## Operator responsibilities

- Run operator node software (ssv-operator/ssv-node):

    - Participate in the DKG during set up or resharing.

    - Respond to signing requests by computing partial signatures from their share.

    - Participate in partial-signature gossip/aggregation or provide partials to an aggregator.

- Availability / liveness:

    - Keep operator node reachable 24/7 with low latency to peers in the cluster.

    - Ensure redundancy (multiple servers / robust networking) to meet SLA.

- Protect the key share:

    - Store share securely (ideally in an HSM or well-protected key store).

    - Prevent leakage — a compromised share contributes toward threshold collusion.

- Run signing/aggregation protocols correctly and with integrity:

    - Follow protocol for partial signature generation and verification.

    - Participate correctly in aggregation (or provide correct partials to an aggregator).

- Participate in operator changes / resharing:

    - If operators are added/removed, participate in resharing/DKG so the new pk and shares are safe.

- Monitor, logging, and alerts:

    - Provide telemetry and SLAs so the staker (or coordinator) can detect downtimes or misbehavior.

- Security & patching:

    - Harden the node, patch crypto libs, apply operational best practices to avoid compromise that would raise collusion risk.

- (Optional) Aggregator role:

    - A node may also act as aggregator to collect t partials and produce the final BLS signature. Aggregators must not be trusted with any single point of failure assumptions — aggregator sees partials but shouldn’t be able to reconstruct the key.

- On-chain responsibilities:

    - Operators are part of the cluster registered on chain; they must respect sequence numbers/validators’ lifecycle, coordinate resharing, and behave to avoid slashing. The staker typically triggers on-chain operations, but operators enable them off-chain.

## Fault tolerance guarantees — precisely what is guaranteed

Think in two dimensions: liveness (can you make signatures when needed?) and safety (can malicious actors make signatures you didn’t authorize?).

- Liveness (availability)

    - Guarantee: As long as ≥ t operators are online and honest, the validator can produce required signatures.

    - Formula: tolerate n − t operators being offline (F_offline = n − t).

    - Implication: Choose a threshold t small enough to handle expected operator outages (e.g., geographic outages).

- Safety (security / anti-collusion)

    - Guarantee: Any group smaller than t cannot produce valid signatures or reconstruct the private key (assuming cryptographic assumptions hold and DKG was honest).

    - Break: If t or more operators collude (or their systems are breached and shares exfiltrated), they can produce signatures or reconstruct the key — i.e., the validator key is compromised.

    - Implication: Choose t large enough and choose operators independent enough such that collusion of size t is implausible.

- Putting both together — practical effect

    - If you want to survive f operator failures, pick t = n − f.

    - But that makes the collusion threshold t = n − f lower if f is large; there’s always a tradeoff.

- Byzantine vs crash failures

    - Crash failures (operators offline): counted in n − t. The protocol tolerates these up to that number.

    - Byzantine failures (malicious operators): If they are fewer than t, they cannot sign alone; but Byzantine behavior can still cause disruption (e.g., by refusing to sign or providing invalid partials), which impacts liveness if enough do so.


## Trust boundaries — who trusts whom

- Staker / deposit owner → cluster: trusts that no more than (t−1) operators collude; trusts operator availability such that ≥ t remain up. The staker does not trust any single operator with the whole key.

- Operators ↔ Operators: do not have to trust each other. DKG ensures no operator learns the whole key. They must trust the correctness of protocol implementations and the DKG outcomes (verifiability mitigates this).

- Aggregator: Typically untrusted for key material, but must be honest in aggregation. Aggregator sees partials and could interfere with liveness by dropping partials, but aggregator alone should not be able to forge signatures.

- On-chain contract: enforces the registered public key pk and operator set (and changes). This is trusted to reflect membership and slashing conditions.

 ## Common failure scenarios & mitigations

- Many operators offline (exceed n − t) → liveness loss.

  - Mitigation: choose t appropriately; run operators across providers/regions; on-call / redundancy.

- t or more operators collude or are compromised → key compromise.

  - Mitigation: choose independent operators, require legal/financial disincentives, prefer HSMs, regular audits.

- Operator misbehavior (invalid partials) → temporary stall or need to swap operator.

  - Mitigation: monitoring + quick operator replacement/reshare.

- Aggregator becomes bottleneck or misbehaves → availability impact.

  - Mitigation: multiple aggregators or gossip aggregation, authenticated partials, fallbacks.

- Network partition: split groups each believe they can sign → risk of equivocation/slashing.

  - Mitigation: careful signing policies, detection of partitions, and protocol rules that prevent double-signing.

- Key rotation / operator replacement: must run resharing (new DKG) to avoid re-exposing the original key. This is an explicit protocol operation.

## Practical rules-of-thumb & example configs

If you value security (prevent collusion) choose a higher t (closer to n). If you value availability choose smaller t.

Example tradeoffs:

- (n=4, t=3) → tolerate 1 offline, collusion requires 3 operators.

- (n=5, t=3) → tolerate 2 offline, collusion requires 3 operators (better availability for same collusion threshold).

- (n=3, t=2) → tolerate 1 offline, collusion requires 2 operators (weak).

Recommended operator selection: independent operators across clouds and jurisdictions; operators with proven uptime and hardened infrastructure; require HSM or encrypted key stores where possible.
